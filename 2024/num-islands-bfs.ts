// Завдання: Кількість островів
// Уявіть собі карту у вигляді двовимірної сітки, де кожна клітинка може бути сушею (1) або водою (0). Острів утворюється з’єднаними сусідніми клітинками суші, і оточений водою. Ваша задача полягає в тому, щоб підрахувати кількість островів на цій карті.
//
//   Сусідніми вважаються клітинки, що з'єднані по горизонталі або вертикалі (не по діагоналі).
//
// Вхідні дані
// grid: двовимірний масив m x n, що складається з 1 (суша) і 0 (вода).
//   Вихідні дані
// Повернути кількість островів.
//   Приклад
// plaintext
// Copy code
// Вхід:
//   grid = [
//     ["1","1","0","0","0"],
//     ["1","1","0","0","0"],
//     ["0","0","1","0","0"],
//     ["0","0","0","1","1"]
//   ]
//
// Вихід:
//   3
// Пояснення:
//
//   Перший острів складається з двох рядків перших двох стовпців.
//   Другий острів — це одиночна клітинка в центрі.
//   Третій острів — це дві суміжні клітинки в нижньому правому куті.
//   Умови:
//
// Ви можете передбачити, що всі чотири краї сітки оточені водою.

function numIslands(grid: string[][]): number {
  if (grid.length === 0) return 0;

  const m = grid.length;
  const n = grid[0].length;
  let count = 0;

  // Визначаємо напрямки для руху (вверх, вниз, вліво, вправо)
  const directions: [number, number][] = [
    [-1, 0], // вверх
    [1, 0],  // вниз
    [0, -1], // вліво
    [0, 1]   // вправо
  ];

  // Функція для обробки BFS
  const bfs = (i: number, j: number) => {
    const queue: [number, number][] = [[i, j]];
    grid[i][j] = '0'; // Помічаємо клітинку як відвідану

    while (queue.length > 0) {
      const [x, y] = queue.shift()!; // Дістаємо елемент з черги

      // Перевіряємо всі напрямки
      for (const [dx, dy] of directions) {
        const newX = x + dx;
        const newY = y + dy;

        // Перевіряємо, чи нова клітинка в межах карти і чи це суша
        if (
          newX >= 0 && newX < m &&
          newY >= 0 && newY < n &&
          grid[newX][newY] === '1'
        ) {
          grid[newX][newY] = '0'; // Помічаємо клітинку як відвідану
          queue.push([newX, newY]); // Додаємо нову клітинку в чергу
        }
      }
    }
  };

  // Основний цикл для обходу всієї сітки
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === '1') {
        count++; // Знайшли новий острів
        bfs(i, j); // Виконуємо BFS для всіх клітинок цього острова
      }
    }
  }

  return count;
}

// Приклад використання
const grid = [
  ["1", "1", "0", "0", "0"],
  ["1", "1", "0", "0", "0"],
  ["0", "0", "1", "0", "0"],
  ["0", "0", "0", "1", "1"]
];

const result = numIslands(grid);
console.log(result); // Виведе 3
